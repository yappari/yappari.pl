---
layout: post

author: kbielen
title: Boost&#58; snippety
abstract: Przykłady kodu wykorzystującego biblioteki boost do&#58; serializacji
          obiektów, rekursywnego iterowania po katalogach oraz
          używania wyrażeń regularnych. Przedstawione przykłady
          zostały zaimplementowane dla bibliotek boost w wersji 1.45.
---

h3. Serializacja obiektów

Poniżej znajduje się przykład wykorzystania biblioteki boost do serializacji struktur danych do buforów znaków.

Należy zainkludować następujące pliki:

{% highlight cpp linenos %}
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/serialization/vector.hpp>
{% endhighlight %}

W celu serializacji struktury/klasy należy stworzyć definicję klasy w następujący sposób:

{% highlight cpp linenos %}
struct MyStruct
{
   int x;
   std::string str;
   std::vector<int> vec;
 
private:
 
   friend class boost::serialization::access;
 
   template<class Archive>
   void serialize(Archive &ar, const unsigned int version)
   {
      ar & x;
      ar & str;
      ar & vec;
   }
}
{% endhighlight %}

W celu serializacji do buffora należy napisać następujący kod:

{% highlight cpp linenos %}
try
{
   std::stringbuf sb;
   boost::archive::binary_oarchive oa(sb);
   oa & data;
 
   int data_size = sb.str().length();
   std::string str = sb.str();
   const char *buff = str.c_str()
 
   // TODO: ...dalsze operacje
}
catch (std::exception &e)
{
   // TODO: obsługa wyjątku
}
{% endhighlight %}

W celu deserializacji należy napisać następujący kod:

{% highlight cpp linenos %}
try
{
   // TODO: ...tutaj tworzymy/odbieramy bufor danych 'buff'
   // o rozmiarze 'buff_size'
   //
   // Uwaga!!! należy zwrócić uwagę na użycie obiektu tymczasowego
   // typu 'std::string'
 
   std::stringbuf sb(std::string(buff, buff_size));
   boost::archive::binary_iarchive ia(sb);
   ia & data;
 
   // TODO: ...dalsze operacje na strukturze danych 'data'
}
catch (std::exception &e)
{
   // TODO: obsługa wyjątku
}
{% endhighlight %}

h3. Rekursywne iterowanie po katalogu

Biblioteka Boost::Filesystem implementuje przydatne funkcje służące do
manipulacji ścieżkami, plikami oraz katalogami systemu plików. Poniżej
znajduje się przykład prezentujący rekursywne iterowanie po katalogu.

{% highlight cpp linenos %}
#include <boost/filesystem.hpp>
 
namespace bf = boost::filesystem;
 
int main()
{
   bf::path path("test_path");
 
   if (bf::exists(path) && bf::is_directory(path))
   { 
      /*
       * Iteratory domyślnie wskazują koniec kolekcji
       */
      bf::recursive_directory_iterator iter(path), end;
      for ( ; iter != end; iter++)
      {
         if (bf::is_regular(iter->status()))
         {
            std::cout << (*iter).string() << std::endl;
         }
      }
   }
 
   return 0;
}
{% endhighlight %}

Program przegląda rekursywnie katalog test_path i wypisuje na standardowe wyjście wszystkie nazwy plików.

W linii nr. 7 tworzymy obiekt typu boost::path, który definiuje
ścieżkę dyskową. Następnie w linii nr. 9 spradzamy, czy obiekt, na który
wskazuje ścieżka istnieje oraz czy jest to katalog. Następnie tworzymy
rekursywny iterator służący do przeglądania katalogu oraz wypisujemy
na wyjście standardowe nazwy wszystkich plików "zwykłych" (funkcja is_regular).
